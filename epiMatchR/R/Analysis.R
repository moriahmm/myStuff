#' Computes weighted correlation between vector/matrix and vector
#'
#' This function computes the weighted correlation between a vector and each column of a dataframe with the same number or rows and returns the output
#' as a data frame. Uses C for computation.
#'
#' @param  toSearch a database matrix of z scores for samples to be compared against sampletoMatch or vector of z scores for a single sample
#' @param  sampleToMatch a vector of z scores from a sample to compare against database. Must contain same number of rows as toSearch.
#' @param  weight a vector of weights. Must have same dimensions as sampleToMatch
#' @useDynLib epiMatchR
#' @return weighted correlation matrix
#' @export
wCor.fxn <- function(toSearch, sampleToMatch=NULL, weight=NULL){
  if(is.null(sampleToMatch)){
    sampleToMatch <- toSearch
  }
  x <- as.matrix(toSearch)
  y <- as.matrix(sampleToMatch)
  if(is.null(weight)){
    weight <- rep(1, dim(x)[1])
  }
  a <- x[!is.na(weight),]
  b <- y[!is.na(weight),]
  weight <- weight[!is.na(weight)]
  a1<-as.matrix(a)
  b1<-as.matrix(b)
  weight1<-as.double(weight)
  out <-wCor2.fxn(a1,b1,weight1)
  if(!is.null(colnames(a)))
    rownames(out) <- colnames(a)
  if(!is.null(colnames(b)))
    colnames(out) <- colnames(b)
  out
}

wCor2.fxn<- function(a,b,weight) {
  .Call("weightedCor", a, b, weight, NAOK=TRUE, PACKAGE='epiMatchR')
  }



#' Computes Correlation
#'
#' This function computes the correlation between a sample of interest and another sample of interest or database of samples
#'
#' @param  toSearch a database matrix of z scores for samples to be compared against sampletoMatch or vector of z scores for a single sample
#' @param  sampleToMatch a vector of z scores from a sample to compare against database. Must contain same number of rows as toSearch.
#' @return correlation matrix
#' @export
cor.fxn<- function(toSearch,sampleToMatch) {
  return(stats::cor(sampleToMatch, toSearch))
}

#' Generates Data Frame that contains number of hits corresponding to each level of a factor in epitopeKey
#'
#' Generates Data Frame that contains number of hits from an input data frame that correspond to each level of a selected
#' factor in an EpitopeKey
#'
#' @param hitDF a data frame of hits with epitope ids in the first column as generated by z2Hit with keepID=TRUE
#' @param key  dataframe containing epitope ids and relevant metadata. The first column must be named 'id' and contain eptiope ids
#' @param group.by  variable in epitope key to count
#' @return data frame
#' @export
epiCount<- function(hitDF,key,group.by) {
  #hitDF$total<-rowSums(hitDF)
  if(!(group.by %in% names(key))) {
    stop("group.by must be a variable in key")
  }
  tmp<-epiMatchR::epIdentity(hitDF,key,keepAllMeta=FALSE,keepMeta=c("id",group.by))
  samples<-(names(tmp))
  idx<-which(samples == group.by)
  idxx<-which(is.na(tmp[,idx]))
  idxxx<-which(tmp[,idx]=="")
  tmp[c(idxx,idxxx),idx]<-"Unknown"
  idx<-which(samples %in% c("id",group.by))
  samples<-samples[-idx]

  idx2<-names(tmp)
  idx3<-which(idx2==group.by)
  epFactors<-unique(tmp[,idx3])
  names(epFactors)<-'b'
  epFactors<-epFactors$b
  tmp2 <- setNames(data.frame(matrix(nrow = length(epFactors), ncol = length(samples))), samples)
  .rowNamesDF(tmp2)<-(epFactors)
  for (j in seq_along (samples)) {
    tmpSamp<-samples[j]
    idx4<-which(idx2==tmpSamp)
    idx5<-which(tmp[,idx4]==1)
    tmpDF<-tmp[idx5,group.by]
    for (i in seq_along (epFactors)) {
      tmpFact<-epFactors[i]
      tmp2[i,j]=length(which(tmpDF==tmpFact))
    }
  }
  return(tmp2)
}

#' Computes weighted correlation between two data frames
#'
#' This function computes the weighted correlations between each column of samplesToMatch with each column of toSearch and returns the output
#' as a data frame. Uses C for computation. Columns containing epitope IDs must be named "id"
#'
#' @param  toSearch a database matrix of z scores for samples to be compared against sampletoMatch or vector of z scores for a single sample
#' @param  samplesToMatch a dataframe of z scores from a sample to compare against database. Must contain same number of rows as toSearch. Each column represents a single sample
#' @param  prevalence a vector of epitope prevalence for each epitope id in samplesToMatch and toSearch
#' @param  a.par,d.par,f.par parameters in weight equation
#' @import data.table
#' @useDynLib epiMatchR
#' @return weighted correlation data frame
#' @export
wCor.df <- function(toSearch, samplesToMatch=NULL, prevalence=NULL,a.par=0.9,d.par=0.03,f.par=0.75){
  #Error if dimensions wrong
  if (length(prevalence)!=nrow(toSearch) || length(prevalence)!=nrow(samplesToMatch))
    {
    stop("toSearch, samplesToMatch, prevalence must have the same number of rows")
    }
  #Remove ID columns
  if ("id" %in% names(toSearch))
    {
      toSearch<-dplyr::select(toSearch,-"id")
    }
  if ("id" %in% names(samplesToMatch))
   {
    samplesToMatch<-select(samplesToMatch,-"id")
    }
  #Compute Adjusted Z scores for Correlation Computation (set anything below 1 to 0.01)
  toSearchAdj<-epiMatchR::setThres2Val(toSearch,value = 0.01)
  toMatchAdj<-epiMatchR::setThres2Val(samplesToMatch,value = 0.01)
  # Modify prevalnce values that are zero
  prevAdj<-prevalence
  v1<-min(prevalence[prevalence!=0])
  prevAdj[prevAdj==0]=v1
  #Create Weight Matrix
  q<-parallel::mcmapply(samplesToMatch,
                        FUN = zWeight,
                        a = a.par,
                        d = d.par,
                        mc.cores = parallel::detectCores()-1)
  weight<-q/(prevAdj*100*f.par)

  #Create Correlation Matrix
  sampleIDs<-names(samplesToMatch)
  nSamples<-length(samplesToMatch)
  corMatrix <-data.frame(matrix(ncol = 0, nrow = nSamples))
  .rowNamesDF(corMatrix)<-sampleIDs
  for (j in seq_along(sampleIDs)){
    toGet <- as.character(sampleIDs[j])[1]
    tempZs <- data.table::setDT(select(toMatchAdj,toGet))
    w<-weight[,toGet]
    tempDF <- data.table::setDT(toSearchAdj)
    v<-tempDF[, parallel::mclapply(X=.SD,
                                   FUN = epiMatchR::wCor.fxn,
                                   sampleToMatch = tempZs,
                                   weight = w,
                                   mc.cores = parallel::detectCores()-1)]
    v<-as.data.frame(t(v))
    names(v)<-toGet
    corMatrix <- corMatrix %>% dplyr::bind_cols(v)
  }
  .rowNamesDF(corMatrix)<-names(toSearch)
  return(corMatrix)
}


zWeight<-function(z,a,d){
  tmp<-((z-a)^2)/(z^2+d)
  return(tmp)
}

















